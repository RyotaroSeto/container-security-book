# 第4章 堅牢なコンテナイメージを作る

## 4.1 コンテナイメージのセキュリティ

### コンテナイメージのセキュリティと脅威
コンテナ運用時のアタックサーフェス(攻撃経路)は以下
- インストールされたソフトウェアやライブラリに既知の脆弱性を悪用した攻撃
- コンテナイメージに格納したクレデンシャルの漏洩
- マルウェアを含むような悪意あるコンテナイメージの使用
- 正規のコンテナイメージの改ざん

## 4.2 コンテナイメージのセキュリティチェック
4.2ではコンテナイメージに含まれるソフトウェアの基地の脆弱性の対応について取り上げる

### コンテナイメージのための脆弱性スキャナ
- コンテナイメージの実態はファイルシステムをレイヤとして保持し、1つにまとめたもの
  - そのため、コンテナイメージを展開してファイルシステムを走査することで、インストールされているソフトウェアやそのバージョンを列挙できる
  - **列挙したソフトウェアの情報を外部の脆弱性データベースと照合することで、コンテナイメージに含まれる既知の脆弱性を洗い出せる**
  - スキャンするツールは以下
    - [Trivy開発者の詳しい記事](https://knqyf263.hatenablog.com/entry/2021/07/29/143500)
    - [Trivy](https://github.com/aquasecurity/trivy)
      - DBなどの事前準備を全て不要にしてとにかく簡単に実行できるよう、RDBは使わず組み込みKVS（BoltDB）を使用
      - 元は日本人の個人開発者が開発したらしい
      - コンテナに含まれるOSパッケージの他にNPMやRubyGemsなどのアプリケーションの依存ライブラリの脆弱性も検出できる
      - DockerfileやKubernetesのマニフェスト、TerraformやCloudFormationなどインフラコードの設定ミスを検出する機能
      - AWSのIAMアクセスキーや各種APIトークンなどを検出する機能
      - スタンドアロン方式とクライアント/サーバー方式の2つの方式で動作させれる
        - スタンドアロン型はサーバなどに接続する必要がなく、ネットワークにも接続していないため、ウイルスや悪意のあるプログラムに感染するリスクが低く、高いセキュリティを担保できる点がメリット。
        - クライアントサーバ型は、クライアント側の端末にアプリケーションをインストールすることでサーバとの通信量を少なくできます。
    - [Clair](https://github.com/quay/clair)
      - クライアント・サーバ型でサーバを事前に準備する必要がありCI/CDのようになるべく状態を持ちたくない環境には不向き
      - コンテナレジストリ向けに作られたもの
      - コンテナレジストリのように大量のイメージをスキャンする上ではClairに大きなアドバンテージがある
      - 各コンテナイメージのメタデータや依存ライブラリをPostgreSQL上で管理
      - 複数のイメージが同じ依存を持つことはザラなので、RDBの参照をうまく使うことで効率的に各イメージの依存性・脆弱性を管理
      - クライアントサーバ型で動作する
      - REST APIを通してスキャンを実行したり、スキャン結果を取得できる
    - [Grype](https://github.com/anchore/grype)
      - クライアントサーバ型で動作する
  - HarborなどのコンテナレジストリやAWSやGCPなどのパプリッククラウドのレジストリにも脆弱性スキャン機能が備わっている
 
### Tribyによるコンテナイメージの脆弱性スキャン

